# -*- coding: utf-8 -*-
"""과제를합시다.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17nrODJlL-wfUZ11DbbDNhvNFAQpGZFNc
"""

import numpy as np
import pandas as pd
import math
from scipy import integrate

"""# 통계계산 과제 2"""

#1

def Quad(x):
    return ((x[1:])**2.0 + 5*(x[:-1])**2.0)

def DQuad(x,y):
    return (np.array([2.0*x,10.0*y]))

!pip install dezero

import numpy as np 
from dezero import Variable

def rosenbrock(x0, x1): 
    y = 100*(x1 - x0 ** 2)*(x1 - x0 ** 2) + (1 - x0) * (1 - x0)
    return y
x0 = Variable(np.array(0.0)) 
x1 = Variable(np.array(2.0)) 
y = rosenbrock(x0, x1) 
y.backward() 

print(x0.grad, x1.grad)

def rosenbrock(x0, x1): 
    y = 100*(x1 - x0 ** 2)*(x1 - x0 ** 2) + (1 - x0) * (1 - x0)
    return y

x0 = Variable(np.array(0.0)) 
x1 = Variable(np.array(2.0)) 
lr = 0.001
iters = 1000

for i in range(iters): 
    print(x0, x1) 
    y = rosenbrock(x0, x1) 
    x0.cleargrad() 
    x1.cleargrad() 
    y.backward() 
    x0.data -= lr * x0.grad 
    x1.data -= lr * x1.grad

def Rosenbrock(x,y):
    return (1 + x)**2 + 100*(y - x**2)**2

def Grad_Rosenbrock(x,y):
    g1 = -400*x*y + 400*x**3 + 2*x -2
    g2 = 200*y -200*x**2
    return np.array([g1,g2])

def Hessian_Rosenbrock(x,y):
    h11 = -400*y + 1200*x**2 + 2
    h12 = -400 * x
    h21 = -400 * x
    h22 = 200
    return np.array([[h11,h12],[h21,h22]])

def Gradient_Descent(Grad,x,y, gamma = 0.00125, epsilon=1e-4 , nMax = 10000 ):
    #Initialization
    i = 0
    iter_x, iter_y, iter_count = np.empty(0),np.empty(0), np.empty(0)
    error = 10
    X = np.array([x,y])
    
    #Looping as long as error is greater than epsilon
    while np.linalg.norm(error) > epsilon and i < nMax:
        i +=1
        iter_x = np.append(iter_x,x)
        iter_y = np.append(iter_y,y)
        iter_count = np.append(iter_count ,i)   
        #print(X) 
        
        X_prev = X
        X = X - gamma * Grad(x,y)
        error = X - X_prev
        x,y = X[0], X[1]
          
    print(X)
    return X, iter_x,iter_y, iter_count


root,iter_x,iter_y, iter_count = Gradient_Descent(Grad_Rosenbrock,-2,2)

[0.91654302 0.83970004]

def f(x):
    f1 = (1 + x[0])**2 + 100*(x[1] - x[0]**2)**2
    return f1

#First Derivative : Gradient, Jacobian

def gradient(x):
    g1 = -400*x[0]*x[1] + 400*x[0]**3 + 2*x[0] -2
    g2 = 200*x[1] -200*x[0]**2
    return np.array([g1,g2])

def jacobian(x):
    h11 = -400*y + 1200*x**2 + 2
    h12 = -400 * x
    h21 = -400 * x
    h22 = 200
    return np.array([[h11,h12],[h21,h22]])

x = [-1, 1]

J_inv = np.linalg.inv(jacobian(x))
J_inv

update = np.matmul(J_inv, gradient(x))

from copy import deepcopy
import numpy as np
def newton(f, init, epsilon=1e-4, verbose=True, history=False):
    """ Newton Raphson Method.
    f: function 
    init: np.array, with dimension n """
    x = deepcopy(init)
    bound = 1e-4
    memo = [x]
    while True:
        J_inv = np.linalg.inv(jacobian(x))
        update = np.matmul(J_inv, gradient(x))
        x = x - update
        if bound > sum(np.abs(update)):
            break
        if verbose: print("x={} update={}".format(x, sum(np.abs(update))))            
        if history: memo.append(x)
    if not history: return x
    return x, np.array(list(zip(*memo)))

ans = newton(f,init=[1, 1], verbose=True)
ans

def Rosenbrock(x,y):
    z = (1 + x)**2 + 100*(y - x**2)**2
    return z

def Grad_Rosenbrock(x,y):
    g1 = -400*x*y + 400*x**3 + 2*x -2
    g2 = 200*y -200*x**2
    return np.array([g1,g2])

def Jaco_Roenbrock()


xt = 100
h = 0.000000001
epsilon = 0.0000001
i = 1
while 1 == True:
    xt1 = xt - Rosenbrock(xt)/Rosenbrock_drv
    dist = abs(xt1 - xt)

    if dist <= epsilon :
        break
    else :
        xt = xt1
        i += 1
print("%s / %s / %s" %i, xt1, Rosenbrock(xt1))

def f(x):
    f1 = 3 * x[0] - cos(x[1] * x[2]) - 3 / 2
    f2 = 4 * (x[0] ** 2) - 625 * (x[1] ** 2) + 2 * x[2] - 1
    f3 = 20 * x[2] + exp(-x[0] * x[1]) + 9
    return f1, f2, f3

f()





"""# 통계계산 과제 3"""

import numpy as np

A = np.array([[1., 2., 3.], [1., 3., 4.], [2., 5., 7.]])

U, Sigma, V = np.linalg.svd(A)
print(Sigma)

def ginvsvd(A):
    U, Sigma, V = np.linalg.svd(A)
    for i in range(3):
        if Sigma[i] < 1e-13:
            Sigma[i] = 0
        else:
          Sigma[i] = 1/Sigma[i]
    A_pinv = np.dot(np.dot(V.transpose(), np.diag(Sigma)), U.transpose())
    return A_pinv

ginvsvd(A)

#pseudo inverse

A_pinv = np.linalg.pinv(A)
print(A_pinv)

ginvsvd(A) == A_pinv





import numpy as np

A = np.array([[1., 2., 3.], [1., 3., 4.], [2., 5., 7.]])

q, r = np.linalg.qr(A)

q #A matrix with orthonormal columns

r #The upper-triangular matrix

np.dot(q, r)

import numpy as np
from scipy import linalg

def gramschmidt(A):
    R = np.zeros((A.shape[1], A.shape[1]))
    Q = np.zeros(A.shape)
    for k in range(0, A.shape[1]):
        R[k, k] = np.sqrt(np.dot(A[:, k], A[:, k]))
        Q[:, k] = A[:, k]/R[k, k]
        for j in range(k+1, A.shape[1]):
            R[k, j] = np.dot(Q[:, k], A[:, j])
            A[:, j] = A[:, j] - R[k, j]*Q[:, k]
    print(f'Q = {Q}')
    print(f'R = {R}')
    print(f'Q^T*Q = {np.dot(Q.transpose(), Q)}')
    print(f'Q*R ={np.dot(Q, R)}')

A = np.array([[8.,-6.,2.],[-4.,11.,-7.],[4.,-7.,6.]])
gramschmidt(A)

q, r = np.linalg.qr(np.array([[8.,-6.,2.],[-4.,11.,-7.],[4.,-7.,6.]]))

q #A matrix with orthonormal columns

r #The upper-triangular matrix

np.dot(q, r)

A = np.array([[8.,-6.,2.],[-4.,11.,-7.],[4.,-7.,6.]])

A[:, 0]

A[:, 1]

for i in range(1,)



q[2]=A[:,1]-np.dot(np.dot(A[:,1].transpose(),q[1]),q[1])
q[3]=A[:,2]-(np.dot(np.dot(A[:,2].transpose(),q[1]),q[1])+np.dot(np.dot(A[:,2].transpose(),q[2]),q[2]))
q[4]=A[:,3]-(np.dot(np.dot(A[:,3].transpose(),q[1]),q[1])+np.dot(np.dot(A[:,3].transpose(),q[2]),q[2])+np.dot(np.dot(A[:,3].transpose(),q[3]),q[3]))

q[4]=A[:,3]-(np.dot(np.dot(A[:,3].transpose(),q[1]),q[1])+np.dot(np.dot(A[:,3].transpose(),q[2]),q[2])+np.dot(np.dot(A[:,3].transpose(),q[3]),q[3]))

q={}
q[1]=A[:,0]/linalg.norm(A[:,0])

q[2]=A[:,1]-np.dot(np.dot(A[:,1].transpose(),q[1]),q[1])
q[2]=q[2]/linalg.norm(q[2])

q[3]=A[:,2]-(np.dot(np.dot(A[:,2].transpose(),q[1]),q[1])+np.dot(np.dot(A[:,2].transpose(),q[2]),q[2]))
q[3]=q[3]/linalg.norm(q[3])

print(q)

import numpy as np
from scipy import linalg

from scipy import linalg



A = np.array([[8.,-6.,2.],[-4.,11.,-7.],[4.,-7.,6.]])

A.shape[1]

q[1]=A[:,0]/linalg.norm(A[:,0])

q[2]=A[:,1]-np.dot(np.dot(A[:,1].transpose(),q[1]),q[1])
q[2]=q[2]/linalg.norm(q[2])

A[:,2]

np.dot(np.dot(A[:,2].transpose(),q[1]),q[1])

np.dot(np.dot(A[:,2].transpose(),q[2]),q[2])

q[3]=A[:,2]-(np.dot(np.dot(A[:,2].transpose(),q[1]),q[1])+np.dot(np.dot(A[:,2].transpose(),q[2]),q[2]))
q[3]

A[:,2]

q[3]=A[1,2]-np.dot(np.dot(A[:,2].transpose(),q[2]),q[2])
q[3]

A[1,2:2]

q = {}
q[1]=A[:,0]/linalg.norm(A[:,0])

q[2]=A[:,1]-np.dot(np.dot(A[:,1].transpose(),q[1]),q[1])
q[2]=q[2]/linalg.norm(q[2])

q[3]=A[:,2]-(np.dot(np.dot(A[:,2].transpose(),q[1]),q[1])+np.dot(np.dot(A[:,2].transpose(),q[2]),q[2]))
q[3]=q[3]/linalg.norm(q[3])

print(q)

#a를 n

q

def orthogonal(A): #A는 n*n정방행렬
  n = A.shaep[0]
  q = {}
  q[1]=A[:,0]/linalg.norm(A[:,0])
  for i in range(1, n):
    q[1]=A[:,0]/linalg.norm(A[:,0])
    sig_i = np.dot(np.dot(A[:,i].transpose(),q[i]),q[i])
    print(sig_i)

list(range(1,4))

A = np.array([[8.,-6.,2.],[-4.,11.,-7.],[4.,-7.,6.]])
q = {}
q[1]=A[:,0]/linalg.norm(A[:,0])
for i in range(1, 3):
  sig = np.dot(np.dot(A[:,i].transpose(),q[i]),q[i])
  print(sig)

A = np.array([[8.,-6.,2.],[-4.,11.,-7.],[4.,-7.,6.]])

q = {}
def ortho(n):
  if n == 1:
    q[n]=A[:,n-1]/linalg.norm(A[:,n-1])



#q[2]=A[:,1]-np.dot(np.dot(A[:,1].transpose(),q[1]),q[1])
#q[3]=A[:,2]-(np.dot(np.dot(A[:,2].transpose(),q[1]),q[1])+np.dot(np.dot(A[:,2].transpose(),q[2]),q[2]))
#q[4]=A[:,3]-(np.dot(np.dot(A[:,3].transpose(),q[1]),q[1])+np.dot(np.dot(A[:,3].transpose(),q[2]),q[2])+np.dot(np.dot(A[:,3].transpose(),q[3]),q[3]))


  return q[i]

def ortho(n):
  ort = np.dot(np.dot(A[:,1].transpose().q[n]

def sum_for_loop(N):
    ret = 0
    for n in range(1, N+1):
        ret += n
    return ret

sum_for_loop(3)

A = np.array([[8.,-6.,2.],[-4.,11.,-7.],[4.,-7.,6.]])

def orth(i, j):
  A = np.array([[8.,-6.,2.],[-4.,11.,-7.],[4.,-7.,6.]])
  q = {}
  q[1]=A[:,0]/linalg.norm(A[:,0])
  return np.dot(np.dot(A[:,i].transpose(),q[j]),q[j])

for i in range(1, 4):
  for j in range(1,i+1):
    orth(i, j)

np.dot(np.dot(A[:,1].transpose(),q[1]),q[1])

def orth(i, j):
  A = np.array([[8.,-6.,2.],[-4.,11.,-7.],[4.,-7.,6.]])
  q = {}
  q[1]=A[:,0]/linalg.norm(A[:,0])
  return np.dot(np.dot(A[:,i].transpose(),q[j]),q[j])

for i in range(1, 3):
  for j in range(1, i+1):
    print(orth(i,j))

list(range(1, 3))

orth(1,1)

orth(2,1)

np.dot(np.dot(A[:,2].transpose(),q[1]),q[1])

np.dot(np.dot(A[:,2].transpose(),q[2]),q[2])

#q[2]=A[:,1]-np.dot(np.dot(A[:,1].transpose(),q[1]),q[1])
#q[3]=A[:,2]-(np.dot(np.dot(A[:,2].transpose(),q[1]),q[1])+np.dot(np.dot(A[:,2].transpose(),q[2]),q[2]))
#q[4]=A[:,3]-(np.dot(np.dot(A[:,3].transpose(),q[1]),q[1])+np.dot(np.dot(A[:,3].transpose(),q[2]),q[2])+np.dot(np.dot(A[:,3].transpose(),q[3]),q[3]))

import numpy as np
from scipy import linalg

def gramschmidt(A):
    global part
    q={}
    q[1]=A[:,0]/linalg.norm(A[:,0])
    for i in range(2,A.shape[0]+1):
        part=0
        for j in range(1,i):
            part+=np.dot(np.dot(A[:,i-1].transpose(),q[j]),q[j])
        q[i]=A[:,i-1]-part
        q[i]=q[i]/linalg.norm(q[i])
    

    return q

Q1 = np.array([k for k in gramschmidt(A).values()])
Q1.T

"""Q = [[ 0.81649658  0.53452248 -0.21821789]
 [-0.40824829  0.80178373  0.43643578]
 [ 0.40824829 -0.26726124  0.87287156]]
"""

q, r = linalg.qr(A)

q

r

np.dot(q, r)

#3*3 gramschmidt's 알고리즘
A = np.array([[8.,-6.,2.], [-4.,11.,-7.], [4.,-7.,6.]])

def gramschmidt(A):
    global part
    q={}
    q[1]=A[:,0]/linalg.norm(A[:,0])
    for i in range(2,4):
        part=0
        for j in range(1,i):
            part+=np.dot(np.dot(A[:,i-1].transpose(),q[j]),q[j])
        q[i]=A[:,i-1]-part
        q[i]=q[i]/linalg.norm(q[i])
    return q

gramschmidt(A)



"""# 고통프 과제 5

Exercise 10.1
"""

def nested_sum(list1):
  if type(list1) != list:
    print(f"Type of '{list1}' must be list")
  else:
    sum_list = []
    for i in range(len(list1)):
      sum_list.append(sum(list1[i]))
    return sum(sum_list)

t = [[1,2], [3], [4,5,6]]
nested_sum(t)

t = [12345]

t2 = [[1,2], [3], [4,5,6],[7,8,9],[10]]
nested_sum(t2)

t3 = 'a'
nested_sum(t3)

"""Exercie 10.4"""

def chop(t):
  if type(t) != list:
    print(f"Type of {t} must be list")
  else:
    lent = len(t)
    for i in range(1, lent-1):
      t.append(t[i])
    del t[:lent]

t = [1,2,3,4]
chop(t)

t

t1 = [1,2,3,4,5,6,7,8]
chop(t1)

t1

"""Exercise 10.5"""

def is_sorted(t):
  if type(t) != list:
    print(f"Type of {t} must be list")
  return t == sorted(t)

is_sorted(['b', 'a'])

is_sorted([1,2,2])

"""Exercise 11.2"""

#setdefault 메서드는 딕셔너리에 key값이 존재하지 않는 경우,
#key의 디폴트 값을 설정해주는 메서드이다.
#setdefault(key[, default])

def invert_dic(d1):
  invert = {}
  for i in list(d1.keys()):
    change = invert.setdefault(d1[i],i)
  return invert

invert_dic({'a' : 1, 'b' : 3, 'c' : 4})

dd = {'name':'juran', 'id':'2020580034'}
invert_dic(dd)

"""Exercise 11.3"""

memo = {}
def ack(m,n):
  if m == 0:
    return n + 1
  elif n == 0:
    return ack(m-1, 1)
  
  if (m, n) in memo:
    return memo[m,n]
  else:
    memo[m,n] = ack(m-1, ack(m, n-1))
    return memo[m,n]

ack(4,1)

for i in range(3):
    a1_text = 'jason {0:02d}번 gate를 통과\n'.format(i)
    print(a1_text)

for i in range(3):
    a1_text = 'jason {0:02d}번 gate를 통과.\n'.format(i) #{0:02d} -> 두자리수, 0 채움
    print(a1_text)

with open("C:\Users\USER\Desktop\test.txt", 'w') as f:
    for i in range(3):
        a1_text = ' {0:02d}번 gate를 통과.\n'.format(i) #{0:02d} -> 2자리수, 0 입력
        f.wirte( a1_text )

with opne("C:\Users\USER\Desktop\test.txt", 'w') as f:
    for i in range(3):
        a1_text = ' {0:02d}번 gate를 통과.\n'.format(i) #{0:02d} -> 2자리수, 0 입력
        f.wirte( a1_text )



"""# 다변량 계산"""

import math

(194.47368 - 179.55)/math.sqrt((39/380)*143.5591)

(267.05263 - 290.8)/math.sqrt((39/380)*367.78777)

(137.36842 - 157.2)/math.sqrt((39/380)*118.31408)

(185.94737 - 209.25)/math.sqrt((39/380)*208.0729)

( - )/math.sqrt((39/380)*)

"""#통계계산 과제4"""

import random

for i in range(1000):
  a = random.uniform(0,1)
  print(f'{a}')

x={}
for i in range(1000):
    x[0]=0
    x[i+1]=(69069*x[i]+1)%(2**32)/(2**32)
print(x)

import numpy as np
import pandas as pd
import random
import scipy.stats


#Chi-Squared Test : 네 그룹으로 나누어 검정
group1 = {}
group2 = {}
group3 = {}
group4 = {}
for i in range(0,250):
  group1[i]=x[i]
for j in range(250,500):
  group2[j-250]=x[j]
for k in range(500,750):
  group3[k-500]=x[k]
for p in range(750,1000):
  group4[p-750]=x[p]
  
    
table=pd.DataFrame([group1, group2, group3, group4])
stat, p, dof, expected=scipy.stats.chi2_contingency(table)
print('stat=%.10f, p=%.10f' % (stat, p))
if p>0.05:
    print("생성된 난수들은 [0,1] 사이의 균일분포를 따름")
else:
    print("생성된 난수들은 [0,1] 사이의 균일분포를 따르지 않음")

#2
from random import uniform
import statistics
import scipy as sp
import scipy.stats

U1=np.random.uniform(0,1,size=10000)
U2=np.random.uniform(0,1,size=10000)


#(a) 추정
print(f'Var(U1+U2) = {statistics.variance(U1+U2)}')
print(f'Var(U1) + Var(U2)= {statistics.variance(U1) + statistics.variance(U2)}')

print(abs(statistics.variance(U1+U2)-(1/6)))
print(abs(statistics.variance(U1) + statistics.variance(U2)-(1/6)))

#(b) 추정
n=10000
event=0
for _ in range(n):
    U1=np.random.uniform(0,1)
    U2=np.random.uniform(0,1)
    if U1+U2<=1.2:
        event+=1
print(f'P(U1+U2 <= 1.2) = {event/n}')

import numpy as np
import random

dice=["1","2","3","4","5","6"]
def pascal(n):
    for i in range(n):
        U1=np.random.choice(dice)
        U2=np.random.choice(dice)
        if U1==U2=="6":
            return("A")
        else:
            return("B")
event=0
for i in range(100000):
    if pascal(24)=="B":
        event+=1
    prob=1-(event/100000)**24 
print(prob)

"""# 고통프 과제 6"""

#12.1

import string

def most_frequent(s):
	d = dict()
	inv = dict()
	for char in s:
		if char in string.ascii_letters:
			letter = char.lower()		
			d[letter] = d.get(letter, 0) + 1
			
	for letter, freq in d.items():
		inv.setdefault(freq, []).append(letter)
		
	for freq in sorted(inv, reverse=True):
		print('{:.2%}:'.format(freq/(sum(list(inv)*len(inv[freq])))), ', '.join(inv[freq]))

most_frequent('aaabbbbbcdefffg')

def most_frequent(s):
    dict = {}
    for letter in s:
        dict[letter] = dict.get(letter, 0) + 1
    freqs = [ (key, value) for (key, value) in sorted(dict.items(), key=lambda x: x[1], reverse=True) ]
    return freqs


print("most frequent hello: {}".format(most_frequent('hello')))

#12.2.1

import pdb

dict = {}
lengths = {}

for line in open("C:/Users/USER/Desktop/word.txt", 'r'):

    word = line.strip()
    key = tuple(sorted(word))
    word_list = dict.get(key, [])
    word_list.append(word)
    dict[key] = word_list

    length = lengths.get(key, 0)
    length += 1
    lengths[key] = length


print("Found {} anagrams".format(len(dict)))
print("Anagrams for {}: {}".format("deltas", dict[tuple(sorted("deltas"))]))

#12.2.2

sorted_anagram_lengths = [key for (key, value) in sorted(lengths.items(), key=lambda item: item[1], reverse=True)]

for index, combo in zip(range(100), sorted_anagram_lengths):
   print("Length {}: {}".format(len(dict[combo]), dict[combo]))

   if len(dict[combo][0]) == 8: print("Combo of length 8: {}".format(combo))

#14.1

import sys

def sed(pattern, replacement, in_path, out_path):

    f_in = open(in_path, 'r')
    new_body = f_in.read().replace(pattern, replacement)
    f_in.close()
    
    f_out = open(out_path, 'w')
    f_out.write(new_body)
    f_out.close()
    
if __name__ == '__main__':
    sed(sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4])

s

"""# 통계계산 과제5"""

#1 로지스틱 분포
#(a) 로지스틱 분포에 대한 역변환법 알고리즘

import math
import random
import scipy.stats
import numpy as np
import matplotlib.pyplot as plt

#로지스틱 함수의 cdf의 역함수
def inv_logistic_df(u):
  return math.log(u/(1-u))

#역변환법 알고리즘
random_num = [random.random() for _ in range(10000)]
random_nums_from_logistic = [inv_logistic_df(ran_num) for ran_num in random_num]

#(b)
#로지스틱 확률함수
x = np.linspace(-10, 10)
y = np.exp(-x)/((1+np.exp(-x))**2)

hist = np.histogram(random_nums_from_logistic)
hist_dist = scipy.stats.rv_histogram(hist)

plt.hist(random_nums_from_logistic, density = True, bins = 50, label = 'random_number')
plt.plot(x,y,label = 'logistic pdf')
plt.legend()
plt.show()

#2번

import math
import numpy as np
import random
import numpy as np
from scipy import stats

#h(x)의 cdf의 역함수 H-1(k)
def H_inv(k):
  return 5 - 2*math.log(1-k)

#g(x)
def g(x):
  return (x*np.exp(-x/2))/(3*np.exp(-5/2))

#역변환법 알고리즘
u1 = [random.random() for _ in range(10000)]
u2 = [random.random() for _ in range(10000)]
random_nums_from_h_inv = [H_inv(ran_num) for ran_num in u1]
gy = [g(i) for i in random_nums_from_h_inv]

accepted = []
rejected = []


if u2 <= gy:
  accepted.extend([random_nums_from_h_inv])
else:
  rejected.append([random_nums_from_h_inv])

#(b)
#감마함수
x = np.linspace(5,10)
y = x*np.exp(-x) / (6*np.exp(-5))

hist1 = np.histogram(random_nums_from_h_inv)
hist_dist1 = scipy.stats.rv_histogram(hist1)

simport matplotlib.pyplot as plt
plt.hist(random_nums_from_h_inv, density = True, bins = 50, label = 'random_number')
plt.plot(x,y,label = 'gamma pdf')
plt.xlim([5,15])
plt.legend()
plt.show()

#3번

import math
import numpy as np
import random
import numpy as np
import scipy
from scipy import stats
import scipy.stats as ss
import matplotlib.pyplot as plt

#평균 -1, 분산1/4
e11 = list(np.random.exponential(1, size = 10000))
e22 = list(np.random.exponential(1, size = 10000))


def p(e):
  return ((e-1)**2) / 2


random_nums = list(p(ran_num) for ran_num in e11)

accepted1 = []
rejected1 = []

for i in range(10000):
  if e2[i] >= random_nums[i]:
    accepted1.extend([e11])
  else:
    rejected1.extend([e11])


for i in range(len(e11)):
  e11[i] = -1 +e11[i]*1/4

for i in range(len(e11)):
  e22[i] = -e11[i]-2



hist11 = np.histogram(e11)
hist_dist11 = scipy.stats.rv_histogram(hist11)
import matplotlib.pyplot as plt
x11 = np.linspace(0,10)
y11 = (2/math.pi*(1/4)**2)**(1/2)*np.exp((-(x1)**2) / 2*(1/4)**2)
plt.hist(e11,density = True, bins = 50)
plt.plot(x11-1,y11, c = 'b')
plt.plot(-x11-1,y11, c= 'b')



e12 = list(np.random.exponential(1, size = 10))
e22 = list(np.random.exponential(1, size = 10))
u32 = list(random.random() for _ in range(10))

accepted1

#temp!!!!!!!!!!!!!!!
#평균 0 분산 1
e12 = list(np.random.exponential(1, size = 10000))
e22 = list(np.random.exponential(1, size = 10000))
u32 = list(random.random() for _ in range(10000))


accepted = []
rejected = []



u = list(random.random() for _ in range(10000))

if 0<= u < 1/2:
  def p(e):
    return ((e-1)**2) / 2

  random_nums = list(p(ran_num) for ran_num in e12)

  for i in range(10000):
    if e22[i] >= random_nums[i]:
      if u32[i] > 0.5:
        accepted1.append(e12[i])
      else:
        accepted1.append(-e12[i])
    else:
      rejected1.extend([e12])


import matplotlib.pyplot as plt

plt.hist(accepted1,density = True, bins = 50)
x12 = np.linspace(0,10)
y12 = ((2*math.exp(1)/math.pi)**(1/2)) *np.exp(-x12) *np.exp(-((x12-1)**2) / 2)
plt.plot(x12,y12, c = 'b')
plt.plot(-x12,y12, c= 'b')

#temp!!!!!!!!!!!!!!!
e12 = list(np.random.exponential(1, size = 10000))
e22 = list(np.random.exponential(1, size = 10000))



def p(e):
  return ((e-1)**2) / 2

random_nums = list(p(ran_num) for ran_num in e12)

accepted1 = []
rejected1 = []

for i in range(10000):
  if e22[i] >= random_nums[i]:
    accepted1.extend([e12])
  else:
    rejected1.extend([e12])

import matplotlib.pyplot as plt
x12 = np.linspace(0,10)
plt.hist(e12,density = True, bins = 50)

x12
y11 = (2/math.pi*(1/4)**2)**(1/2)*np.exp((-(x1)**2) / 2*(1/4)**2)
plt.hist(e11,density = True, bins = 50)
plt.plot(x11-1,y11, c = 'b')
plt.plot(-x11-1,y11, c= 'b')

#평균 1, 분산1/2
e13 = list(np.random.exponential(2, size = 10000))
e23 = list(np.random.exponential(2, size = 10000))


def p(e):
  return ((e-21)**2) / 100

random_nums = list(p(ran_num) for ran_num in e13)

accepted1 = []
rejected1 = []

for i in range(10000):
  if e23[i] >= random_nums[i]:
    accepted1.extend([e13])
  else:
    rejected1.extend([e13])

for i in range(len(e13)):
  e13[i] = e13[i]+1

for i in range(len(e13)):
  e23[i] = -e13[i]+2



hist113 = np.histogram(e13)
hist_dist113 = scipy.stats.rv_histogram(hist113)
import matplotlib.pyplot as plt
x13 = np.linspace(0,10)
y13 = (2/math.pi*(1/4)**2)**(1/2)*np.exp((-(x1)**2) / 2*(1/4)**2)
plt.hist(e13,density = True, bins = 50)
plt.hist(e23,density = True, bins = 50)
plt.plot(x13+1,y13, c = 'b')
plt.plot(-x13+1,y13, c= 'b')

e12 = list(np.random.exponential(1, size = 10000))
e22 = list(np.random.exponential(1, size = 10000))
u32 = list(random.random() for _ in range(10000))


accepted = []
rejected = []



u = list(random.random() for _ in range(10000))

if 0<= u < 1/2:
  def p(e):
    return ((e-1)**2) / 2

  random_nums = list(p(ran_num) for ran_num in e12)

  for i in range(10000):
    if e22[i] >= random_nums[i]:
      if u32[i] > 0.5:
        accepted1.append(e12[i])
      else:
        accepted1.append(-e12[i])
    else:
      rejected1.extend([e12])
for

import math
import numpy as np
import random
import numpy as np
import scipy
from scipy import stats
import scipy.stats as ss
import matplotlib.pyplot as plt

e1 = list(np.random.exponential(1, size = 10000))
e2 = list(np.random.exponential(1, size = 10000))
u1 = list(random.random() for _ in range(10000))
u2 = list(random.random() for _ in range(10000))

accepted = []

def p1(e):
  return ((e-1)**2) / 2

def p2(e):
  return ((e-1)**2)/32

def p3(e):
  return ((e-1)**2)/8


u = list(random.random() for _ in range(10000))

for i in range(10000):
  if 0<= u1[i] < 1/2:
    random_nums = list(p1(ran_num) for ran_num in e1)
    if e2[i] >= random_nums[i]:
      if u2[i] > 0.5:
        accepted.append(e1[i])
      else:
        accepted.append(-e1[i])

  if 1/2 <= u1[i] < 5/6:
    random_nums = list(p(ran_num) for ran_num in e1)
    if e2[i] >= random_nums[i]:
      if u2[i] > 0.5:
        accepted.append(e1[i])
      else:
        accepted.append(-e1[i])

  if 5/6 <= u1[i] < 1:
    random_nums = list(p(ran_num) for ran_num in e1)
    if e2[i] >= random_nums[i]:
      if u2[i] > 0.5:
        accepted.append(e1[i])
      else:
        accepted.append(-e1[i])
    




#혼합정규분포의 모수
norm_params = np.array([[-1, 1/4],
                        [0, 1],
                        [1, 1/2]])

# 가중치
weights = np.array([1/2, 1/3, 1/6])

# f(x) 도출
xs = np.linspace(-3, 3, 20000)
ys = np.zeros_like(xs)


for (l, s), w in zip(norm_params, weights):
    ys += ss.norm.pdf(xs, loc=l, scale=s) * w

plt.plot(xs, ys)
plt.hist(accepted,density = True, bins = 50)

e1 = list(np.random.exponential(1, size = 10000))
e2 = list(np.random.exponential(1, size = 10000))
u1 = list(random.random() for _ in range(10000))
u2 = list(random.random() for _ in range(10000))

accepted = []
rejected = []

def p1(e):
  return ((e-1)**2) / 2

u = list(random.random() for _ in range(10000))

for i in range(10000):
  if 0<= u1[i] < 1/2:
    random_nums = list(p1(ran_num) for ran_num in e1)
    if e2[i] >= random_nums[i]:
      if u2[i] > 0.5:
        accepted.append(e1[i])
      else:
        accepted.append(-e1[i])
  else:
    rejected.append(e1[i])



#혼합정규분포의 모수
norm_params = np.array([[-1, 1/4],
                        [0, 1],
                        [1, 1/2]])

# 가중치
weights = np.array([1/2, 1/3, 1/6])

# f(x) 도출
xs = np.linspace(-3, 3, 20000)
ys = np.zeros_like(xs)


for (l, s), w in zip(norm_params, weights):
    ys += ss.norm.pdf(xs, loc=l, scale=s) * w

plt.plot(xs, ys)
plt.hist(accepted,density = True, bins = 50)

"""# 고통프 과제 7"""

import math
import pdb

class Point:
    def __init__(self, x = 0, y = 0):
        self.x = x
        self.y = y

    def distance(self, other):
        return math.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)

class LineSegment:
    def __init__(self, pointA=Point(), pointB = Point(1,1)):
        self.pointA = pointA
        self.pointB = pointB
        self.x = pointB.x - pointA.x
        self.y = pointB.y - pointA.y

    def dot_product(self, other):
        return self.x * other.x + self.y * other.y

    def distance(self, pointE):
        be = LineSegment(self.pointB, pointE)
        ae = LineSegment(self.pointA, pointE)

        if self.dot_product(be) > 0: return self.pointB.distance(pointE)
        if self.dot_product(ae) < 0: return self.pointA.distance(pointE)
        else: return Line(self.pointA, self.pointB).distance(pointE)

class Line:
    def __init__(self, pointA = Point(), pointB = Point(1,1)):
        self.pointA = pointA
        self.pointB = pointB

    def distance(self, other_point):
        return (
            abs(
              (self.pointB.x - self.pointA.x) * (self.pointA.y - other_point.y) - (self.pointA.x - other_point.x) * (self.pointB.y - self.pointA.y)
        ) / (
            math.sqrt(
                ((self.pointB.x - self.pointA.x)**2 + ((self.pointB.y - self.pointA.y)**2))
            ))
        )
    
        
class Circle:
    def __init__(self, centre = Point(0,0), radius=1):
        self.centre = centre
        self.radius = radius
    

class Rectangle:
    def __init__(self, point = Point(), width = 1, height = 1):
        self.bl = point #bottom left
        self.width = width
        self.height = height

    def vertices(self):
        return [
            self.bl,
            Point(self.bl.x, self.bl.y + self.height),
            Point(self.bl.x + self.width, self.bl.y + self.height),
            Point(self.bl.x + self.width, self.bl.y)
            ]
            

            
def rect_in_circle(circ, rect):
    for point in rect.vertices():
        if not point_in_circle(circ, point):       
            return False

    return True


def rect_circle_overlap(circ, rect):
    vl = rect.vertices()
    for a in range(len(vl)):
        p1 = vl[a]
        p2 = vl[(a + 1) % len(vl)]
        d = LineSegment(p1, p2).distance(circ.centre)
        if math.isclose(d, circ.radius) | circ.radius >= d:
            return True

    return False


if __name__ == '__main__':
    c = Circle()
    c.centre = Point() 
    c.centre.x = 150
    c.centre.y = 100
    c.radius = 75

    r = Rectangle(Point(0, 0), 100, 100)
    print(f'r in c: {rect_in_circle(c, r)}')

    v1 = LineSegment(Point(), Point(1,1))
    print(f'v1 in c: {rect_circle_overlap(c, r)}')

today = datetime.today()
print(f"오늘 날짜: {today}")
print(f"오늘 요일: " + today.strftime("%A"))

bday = '09/15/1997'
bday = datetime.strptime(bday, '%m/%d/%Y')

next_bday = bday.replace(year=today.year)
if next_bday < today:
  next_bday = next_bday.replace(year=today.year+1)

print(next_bday)
until_next_bday = next_bday - today
print(until_next_bday)

def double_day(bday1, bday2):
  bday1 = datetime.strptime(bday1, '%m/%d/%Y')
  bday2 = datetime.strptime(bday2, '%m/%d/%Y')

  double_day = max(bday1, bday2) + abs(bday1-bday2)

  return double_day

double_day('09/15/1997', '02/01/2001')

def get_n_times_older(bday1, bday2, n):
  bday1 = datetime.strptime(bday1, '%m/%d/%Y')
  bday2 = datetime.strptime(bday2, '%m/%d/%Y')
  if bday1 == bday2:
    print("생일이 같음")
  else:
    ordered_bdays = sorted([bday1, bday2])
  return ordered_bdays[0] + n * (ordered_bdays[1] - ordered_bdays[0])

get_n_times_older('09/15/1997', '02/01/2001', 2)

get_n_times_older('09/15/1997', '02/01/2001', 4)



"""# 통계계산 과제6"""

import sympy as sy
#참값 i
y = sy.symbols('y')
i = float(sy.integrate(sy.exp(-y), (y,1,2)))
i

#1 (a)
#난수에 기반한 적중법 추정치 I1
import numpy as np
import matplotlib.pyplot as plt

def func1(x):
    return np.exp(-x)


n = 100
hits = 0
misses = 0
xH = []
yH = []
xM = []
yM = []
for i in range(n):
    xx = np.random.uniform(1,2)
    yy = np.random.uniform()
    if yy <= func1(xx):
        hits += 1
        xH = xH + [xx]
        yH = yH + [yy]
    else:
        misses += 1
        xM = xM + [xx]
        yM = yM + [yy]
i1 = hits/n
print('The Hit & Miss estimate of the integral of f(x) on 1 < x < 2 is', i1)

var1 = np.var(np.random.uniform(1, 2, 10000)+np.log(np.random.uniform(0, 1, 10000))<=0)/10000
var1

#1 (a)
#표본평균 몬테칼로 추정치 I2
import numpy as np

def func1(x):
    return np.exp(-x)
  
def mc_integrate(func, a, b, n):
    # Monte Carlo integration between x1 and x2 of given function from a to b
    
    vals = np.random.uniform(a, b, n)
    y = [func(val) for val in vals]
    
    y_mean = np.sum(y)/n
    integ = (b-a) * y_mean
    
    return integ

i2 = mc_integrate(func1, 1, 2, 100)
print(f"Monte Carlo solution: {i2: .10f}")

plt.plot(xH, yH, 'ro', fillstyle = 'none', markersize = 1.5)
plt.plot(xM, yM, 'bo', fillstyle = 'none', markersize = 1.5)
xx = np.arange(1, 2, 0.001)
plt.plot(xx, func1(xx), 'k-', linewidth = 3)
plt.xlabel('x')
plt.ylabel('f(x)');

var2 = (np.mean(np.exp(-2*np.random.uniform(1,2,10000)))-i**2)/10000
var2

var1 - var2

#2번

#참값 ii
import sympy as sy
#참값 i
y = sy.symbols('y')
ii = float(sy.integrate(sy.sqrt(1-y**2), (y,0,1)))
ii

#표본평균 몬테칼로 추정치 i11
import numpy as np
import math

def func2(x):
    return math.sqrt(1-x**2)
  
def mc_integrate(func, a, b, n):
    # Monte Carlo integration between x1 and x2 of given function from a to b
    
    vals = np.random.uniform(a, b, n)
    y = [func(val) for val in vals]
    
    y_mean = np.sum(y)/n
    integ = (b-a) * y_mean
    
    return integ

i11 = mc_integrate(func2, 0, 1, 100)
print(f"Monte Carlo solution: {i11: .4f}")

var11 = (np.mean(1-np.random.uniform(0,1,10000)**2)-I**2)/10000
var11

#난수에 기반한 대조변수 몬테칼로 추정치 i22
def func2(x):
    return math.sqrt(1-x**2)
u = np.random.uniform(0,1,100)
i22 = 0
for i in range(50):
  i22 += (func2(u[i]) + func2(1-u[i]))/100
print(i22)

n = 10000
var22 = ((np.mean(1-np.random.uniform(0,1, int(n/2))**2)-I**2)+(np.mean(1-(1-np.random.uniform(0,1, int(n/2)))**2)-I**2))/(2*n)
var22

#대조변수법을 사용하는 경우 표본평균 몬테칼로 적분법에 대한 추정량의 분산감소 비율
var22/var11

import numpy as np
from scipy import integrate
import math

#(c) 주표본기법

def g(x):
  return (1-x**2)**0.5

def f1(x):
    return (6/5)*(1-x*x/2)

x = np.random.uniform(0,1,10000)
i111 = 0
for i in range(10000):
  i111 += (5*(1-x[i]*x[i])**0.5) / (6*((1-x[i]*x[i]/2)))

i111 = i111/10000
i111

var111 = np.var((5*(1-x*x)**0.5) / (6*((1-x*x/2))))/10000
var111

def g(x):
  return (1-x**2)**0.5
  
def f2(x):
  return 1

x2 = np.random.uniform(0,1,10000)

i222 = 0

for i in range(10000):
  i222 += math.sqrt(1-x2[i]*x2[i])

i222 = i222/10000
i222

var222 = np.var((1-(x2)**2)**0.5)/10000
var222

var222 > var111



"""# 고통프 과제8"""

import numpy as np

